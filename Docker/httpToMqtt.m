% function response = httpToMqtt(messdauer, abtastrate)

function result = httpToMqtt(ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10, ch11, ch12, ...
    eh1, eh2, eh3, eh4, eh5, eh6, eh7, eh8, eh9, eh10, eh11, eh12, ...
    mr1, mr2, mr3, mr4, mr5, mr6, mr7, mr8, mr9, mr10, mr11, mr12,...
    no1, no2, no3, no4, no5, no6, no7, no8, no9, no10, no11, no12,...
    mQ0, mQ1, mQ2, mQ3, mQ4, mQ5, mQ6, mQ7, mQ8, mQ9, mQ10, mQ11,...
    startStop, sensiArray, abtastrateHz, measurementName)
    % Diese Funktion nimmt 37 Strings, ein Zahlenarray und eine einzelne Zahl als Eingabe
    % und gibt einen kombinierten String zurück
    %
    % Eingabe:
    %   ch1 - ch12 - Einzelne channels -strings
    %   eh1 - eh12  - Einheiten -string
    %   mr1 - mr12  - Messrichtungen - string
    %   startStop   - string
    %   sensiArray  - Array von Sensitivity - double
    %   nabtastrateHz       - Abtastrate  - double 
  
    % Diese Funktion verpackt die Eingabedaten in ein JSON-Format
    % und sendet die Nachricht über MQTT

    % MQTT-Broker-Adresse und Topic
    mqttClient = mqttclient("tcp://host.docker.internal:1884");
    topic = "test/control"; % MQTT-Topic anpassen

    % JSON-Struktur erstellen
    jsonData = struct( ...
    'channel', { {ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10, ch11, ch12} }, ...
    'einheit', { {eh1, eh2, eh3, eh4, eh5, eh6, eh7, eh8, eh9, eh10, eh11, eh12} }, ...
    'messrichtung', { {mr1, mr2, mr3, mr4, mr5, mr6, mr7, mr8, mr9, mr10, mr11, mr12} }, ...
    'notizen', {{no1, no2, no3, no4, no5, no6, no7, no8, no9, no10, no11, no12}},...
    'measuredQuantity', {{mQ0, mQ1, mQ2, mQ3, mQ4, mQ5, mQ6, mQ7, mQ8, mQ9, mQ10, mQ11}},...
    'sensiArray', sensiArray, ...
    'startStop', startStop, ...
    'abtastrateHz', abtastrateHz, ...
    'measurementName', measurementName ...
);

    % JSON konvertieren
    jsonMessage = jsonencode(jsonData);

    write(mqttClient, topic, jsonMessage);

    % Erfolgreiche Verarbeitung zurückgeben
    result = "JSON gesendet: " + jsonMessage;
end

